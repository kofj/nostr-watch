<template>
  <div :class="mapToggleClass">
    <div class="absolute top-0 right-0 width:100%"></div>
    
    <l-map
      ref="map"
      v-model:zoom="zoom"
      v-model:minZoom="minZoom"
      v-model:maxZoom="maxZoom"
      :zoomControl="false"
      :dragging="false"
      :touchZoom="false"
      :scrollWheelZoom="false"
      :doubleClickZoom="false"
      >
      <l-tile-layer
        url="http://{s}.tile.osm.org/{z}/{x}/{y}.png"
        layer-type="base"
        name="OpenStreetMap"
        attribution='<a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      />
      <l-circle-marker
        v-for="relay in getRelaysWithGeo.filter( () => this.showCircles )"
        :lat-lng="getLatLng(relay)"
        :key="relay"
        :radius="2"
        :weight="4"
        :color="getColorViz(relay)"
        :fillOpacity="1" >
      </l-circle-marker>
      
      <l-marker
        v-for="relay in getRelaysWithGeo.filter( () => this.showMarkers )"
        :lat-lng="getLatLng(relay)"
        :key="relay"
        :radius="2"
        :weight="4"
        :fillOpacity="1" >

        <l-popup :maxWidth="auto">
          <div class="mb-10 w-min">
            <div class="text-slate-800 text-3xl  block py-1 text-center">
              <span @click="copy" class="py-1px-2">{{ relay }}</span>
              <a href="#" @click="$router.push(`/relay/${getHostname(relay)}`)" class="block text-sm mb-3">Status Page</a>
              <img class="inline-block mr-1" :src="badgeCheck(relay, 'connect')" />
              <img class="inline-block mr-1" :src="badgeCheck(relay, 'read')" />
              <img class="inline-block mr-1" :src="badgeCheck(relay, 'write')" />
            </div>
          </div>
        </l-popup>
      </l-marker>

    </l-map>
    <span id="map_control" class="content-center text-center hidden lg:block">
      <button @click="this.handleToggleMap()" class="bg-white hover:bg-gray-100 dark:bg-slate-800 dark:hover:bg-slate-900 text-gray-800 dark:text-gray-200 font-semibold py-2 px-4 border border-gray-400 dark:border-white/10 rounded shadow" v-if="!store.layout.mapIsExpanded">full map</button>
      <button @click="this.handleToggleMap()" class="bg-white hover:bg-gray-100 text-gray-800 font-semibold py-2 px-4 border border-gray-400 rounded shadow" v-if="store.layout.mapIsExpanded">relay list</button>
    </span>
  </div>
  
</template>

<style>
.leaflet-popup-content-wrapper {
  @apply dark:bg-black/80
}
</style>

<script>
import { defineComponent, toRefs } from 'vue'
import "leaflet/dist/leaflet.css"
import { LMap, LTileLayer, LCircleMarker, LMarker, LPopup } from "@vue-leaflet/vue-leaflet"

import { setupStore } from '@/store'

import RelaysLib from '@/shared/relays-lib.js'

export default defineComponent({
  name: "MapSummary",
  components: {
    LMap,
    LTileLayer,
    LCircleMarker,
    LMarker,
    LPopup,
  },
  
  setup(props){
    const {activeSubsectionProp: activeSubsection} = toRefs(props)
    return { 
      store : setupStore(),
      activeSubsection: activeSubsection
    }
  },

  data() {
    return {
      zoom: this.store.layout.mapIsExpanded ? 4 : 2,
      minZoom: 2,
      maxZoom: 7,
      // center: this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [70.41322, -1.219482],
      expanded: this.store.layout.mapIsExpanded ? true : false,
      relays: []
    };
  }, 
  beforeMount(){
    // this.shiftMap()
  },

 async mounted() {
    this.geo = this.store.relays.geo
    this.mapInit()
  },
  beforeUnmount(){
    //console.log('beforeUnmount', '$refs', this.$refs)
  },
  // unmounted(){
  //   //console.log('unmounted', '$refs', this.$refs)
  //   delete this.$refs.map
  // },
  updated(){},
  props: {
    activeSubsectionProp: {
      type: String,
      default(){
        return ""
      }
    },
  },
  computed: {
    subsectionRelays(){
      return this.getRelays( this.store.relays.getRelays(this.activeSubsection, this.store.results.all ) )
    },
    relayUrl() {
      // We will see what `params` is shortly
      return `wss://${this.$route.params.relayUrl}`
    },
    badgeNip(){
      return (nip) => `https://img.shields.io/static/v1?style=for-the-badge&label=NIP&message=${this.nipSignature(nip)}&color=black`
    },
    badgeCheck(){
      return (relay, key) => `https://img.shields.io/static/v1?style=for-the-badge&label=&message=${key}&color=${this.store.results.get(relay)?.check?.[key] ? 'green' : 'red'}`
    },
    nipSignature(){
      return (key) => key.toString().length == 1 ? `0${key}` : key
    },
    nipFormatted(){
      return (key) => `NIP-${this.nipSignature(key)}`
    },
    nipLink(){
      return (key) => `https://github.com/nostr-protocol/nips/blob/master/${this.nipSignature(key)}.md`
    },
    getCircleClass(){
      //console.log('the relay', relay)
      return (relay) => {
        return {
          visible: this.isRelayInActiveSubsection(relay),
          hidden: !this.isRelayInActiveSubsection(relay),
          [relay]: true
        }
      }
    },
    getRelaysWithGeo(){
      return this.getRelays( this.store.relays.getAll.filter( relay => this.geo?.[relay] instanceof Object) ) 
    },
    isRelayInActiveSubsection(){
      return (relay) => this.store.relays.getRelays(this.activeSubsection, this.store.results.all).includes(relay)
    },
    getColorViz(){
      return (relay) => {
        if(!this.isRelayInActiveSubsection(relay))
          return 'transparent'

        if(this.store.results.get(relay)?.aggregate == 'public')
          return '#00AA00'

        if(this.store.results.get(relay)?.aggregate == 'restricted')
          return '#FFA500'

        if(this.store.results.get(relay)?.aggregate == 'offline')
          return '#FF0000'
        
        return 'transparent'
      }
    },
    showCircles(){
      //console.log('map is collapsed', !this.store.layout.mapIsExpanded)
      return !this.store.layout.mapIsExpanded
    },
    showMarkers(){
      //console.log('map is expanded', this.store.layout.mapIsExpanded)
      return this.store.layout.mapIsExpanded
    },
    getLat(){
      return (relay) => this.geo[relay].lat
    },
    getLon(){
      return (relay) => this.geo[relay].lon
    },
    mapToggleClass(){
      return {
        'expanded relative min-h-screen': this.store.layout.mapIsExpanded
      }
    },
  },
  methods: Object.assign(RelaysLib, {
    mapInit(){
      setTimeout( () => {
        if(this.$refs?.map?.leafletObject?.whenReady)
          this.$refs?.map?.leafletObject?.whenReady(async () => {
            await this.$refs.map.leafletObject
              .setView(
                this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [35.41322, -1.219482], 
                this.store.layout.mapIsExpanded ? 4 : 2
              )
          })
      }, 1000)
    },
    async copy(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch($e) {
        ////console.log('Cannot copy');
      }
    },
    getLatLng(relay){
      return [this.getLat(relay), this.getLon(relay)]
    },
    async handleToggleMap(){
      //console.log('toggle state', this.store.layout.mapIsExpanded, this.$refs.map.leafletObject)
      this.store.layout.toggleMap()

      if(this.store.layout.mapIsExpanded)
        this.$refs.map.leafletObject.dragging.enable()
        

      // // this.$refs.map.leafletObject.setZoom();
      // this.$refs.map.leafletObject
      //       .setView(
      //         this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [35.41322, -1.219482],
      //         this.store.layout.mapIsExpanded ? 4 : 2
      //       )

      await this.$refs.map.leafletObject
            .flyTo(
              this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [35.41322, -1.219482], 
              this.store.layout.mapIsExpanded ? 4 : 2
            )
      
      // await this.$refs.map.leafletObject
      //         .flyTo(
      //           this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [35.41322, -1.219482], 
                
      //         )
      this.refreshMap()
        // .panTo(this.store.layout.mapIsExpanded ? [40.41322, -1.219482] : [70.41322, -1.219482])
      // this.shiftMap()
      //console.log('toggle state', this.store.layout.mapIsExpanded)
    },
    resetMapSize(){
      console.dir('reset map size?', this.$refs.map.leafletObject)
      if (this.$refs.map.ready) 
        this.$refs.map.leafletObject.invalidateSize()
    },
    shiftMap(){
      if(!this.store.layout.mapIsExpanded) {
        // this.center = [70.41322, -1.219482]
        this.minZoom = 2
        this.maxZoom = 2
      }
      if(this.store.layout.mapIsExpanded) {
        // this.center = [34.41322, -1.219482]
        this.minZoom = 4
        this.maxZoom = 7
      }
    },
    refreshMap(){
      // this.shiftMap()
      setTimeout(this.resetMapSize(), 1 )
    },
  }),
  
});


</script>

<style>
/* :root {
    --map-tiles-filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
}

@media (prefers-color-scheme: dark) {
    .leaflet-tile {
        filter:var(--map-tiles-filter, none);
	}
} */
</style>

<style>

.leaflet-popup-content {
  width: auto !important;
}
</style>

<style scoped>


.leaflet-container {
  position:relative;
  z-index:900;
  margin:0;
  padding:0;
  height:250px !important;
  width:100%;
/*  -webkit-transition:height 300ms ease-in-out;
  -moz-transition:height 300ms ease-in-out;
  -o-transition:height 300ms ease-in-out;
  transition:height 300ms ease-in-out;*/
}


.expanded .leaflet-container {
  position:absolute;
  z-index:900;
  margin:0;
  padding:0;
  top:0;
  bottom:0;
  width:100%;
  height:100% !important;
}

/* .expanded .leaflet-container {
  height:555px !important;
} */
.leaflet-control-zoom {
  display: none;
}



.expanded .leaflet-control-zoom {
  display: block !important;
}

button {
  position: relative;
  z-index:901;
  top: -30px;
  cursor:pointer;
}

.expanded button {
  top:-22px
}

button:hover {
  background-color: white;
}


/* button:hover {
  color:#222;
}

.expanded button .expand,
button .collapse {
  display:none;
}

button .expand,
.expanded button .collapse {
  display:inline;
} */
</style>

